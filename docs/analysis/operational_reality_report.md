# TwinStar Quantum: 구동 현실 및 리스크 진단 보고서 (v2.1)

본 보고서는 프로젝트의 특성과 AI 협업 개발 방식에서 비롯되는 **지속적인 문제점**과 **실제 구동 환경에서의 취약점**을 객관적으로 진단합니다.

---

## 1. 프로젝트의 특이점과 AI 협업의 현실

### 🔴 개발 속도와 코드 부채의 충돌
AI(Antigravity)는 매우 빠른 속도로 기능을 추가하고 파일을 수정합니다. 하지만 이 속도가 **전체 구조의 정밀한 정합성**을 앞설 때가 있습니다.
- **현실**: 기능은 돌아가지만, 내부적으로는 비슷한 로직이 여러 곳에 흩어져 있는 '파편화(Fragmentation)'가 진행 중입니다. (예: 싱글 매매와 멀티 매매의 진입 로직이 미묘하게 다름)

### 🔴 GUI 환경의 블랙박스 특성
저는 코드를 고치고 스크린샷은 볼 수 있지만, **실제 사용자PC에서의 미세한 프레임 드랍, 클릭 반응성, 혹은 네트워크 지연에 따른 프리징**을 100% 체감하지 못합니다.
- **현실**: 코드상으로 완벽해 보이는 비동기(asyncio) 로직이 실제 EXE 환경에서는 OS 자원 관리 문제로 예기치 못한 종료를 유발할 수 있습니다.

---

## 2. 지속되는 고질적 문제 (Critical Pain Points)

### 1️⃣ 패키징(EXE) 하이브리드 경로 문제
- **징후**: 개발 환경(py)에서는 잘 되는데, 빌드(exe)만 하면 파일 못 찾음(FileNotFound) 혹은 모듈 없음(ImportError) 발생.
- **원인**: `pathlib` 도입으로 개선 중이나, 여전히 일부 레거시 코드나 외부 라이브러리가 `sys.executable`과 `_MEIPASS` 사이에서 방황합니다.

### 2️⃣ 비동기(Async) 생명주기 관리 실패
- **징후**: 웹소켓 연결 해제 시 혹은 프로그램 종료 시 에러 팝업 발생.
- **원인**: PyQt5의 이벤트 루프와 `asyncio` 루프가 서로 다른 스레드에서 '누가 주도권을 가질 것인가'에 대한 정립이 완벽하지 않습니다. 이는 시스템이 커질수록 메모리 누수로 이어집니다.

### 3️⃣ 데이터 무결성 및 지연 (Data Lag)
- **징후**: 시그널은 떴는데 진입 가격이 다르거나, 최적화(AutoOptimizer)가 엉뚱한 결과 도출.
- **원인**: 거래소의 15분 데이터와 사용자의 1분 로컬 캐시가 동기화되지 않을 때 발생합니다. "실시간성"을 표방하지만 내부적으로는 "준-실시간(Near Real-time)"에 머물러 있는 현실입니다.

---

## 3. 지속 가능한 구동을 위한 전략적 제언

### ✅ "Zero-Config" 지향
사용자가 매번 레버리지를 바꾸고 프리셋을 수동으로 옮기는 것은 사고의 원인입니다. 
- **대안**: 이번에 도입된 `get_or_create_preset`처럼, 모든 매매 모드가 **"버튼 하나로 최적 값을 스스로 찾아가는 구조"**로 완전히 전환되어야 합니다.

### ✅ "Build Automation"으로의 전환
지금처럼 수동으로 `.spec`을 고치는 것은 "인재(人災)"를 기다리는 것과 같습니다.
- **대안**: 빌드 시 프로젝트 전체 폴더를 스캔하여 모든 하위 모듈을 자동으로 `hiddenimports`에 집어넣는 자동화 스크립트를 표준으로 사용해야 합니다.

### ✅ "Strategy-First, UI-Second"
현재는 UI 개발이 로직 개발을 이끌고 있습니다. 
- **대안**: 모든 트레이딩 로직은 UI 없이도 독립적으로 돌아가는 'Headless' 엔진으로 먼저 완성되어야 합니다. UI는 그 엔진의 상태를 보여주는 '창' 역할에 충실해야 안정성이 확보됩니다.

---

> [!CAUTION]
> **결론적으로, 현재 프로젝트는 "기능의 풍요 속의 빈곤" 상태입니다.** 
> 화려한 UI 뒤에서 실시간 데이터 가닥이 엉켜있을 리스크가 상존합니다. 지금은 신규 기능을 더 추가하기보다, **기존 로직의 '단일화(Unification)'와 '비동기 안전성(Async Safety)'** 확보에 집중해야 할 시점입니다.
