# 📋 백테스트 메트릭 재현성 문제 해결 계획서

**작성일**: 2026-01-17
**버전**: v1.0
**예상 소요 시간**: 3-4시간
**심각도**: 🔴 CRITICAL
**작업자**: Claude Opus 4.5

---

## 🎯 목표 (Goal)

**문제**: 동일한 데이터/파라미터로 백테스트 2회 실행 시 **MDD가 66% 차이** 발생
**목표**: MDD 재현성 ±1% 이내로 개선 (현재: -66% → 목표: ±1%)

---

## 🔍 문제 분석 (Problem Analysis)

### 근본 원인

**`core/optimizer.py:1404-1429`의 PnL 클램핑**:

```python
# 현재 코드 (문제)
MAX_SINGLE_PNL = 50.0   # 단일 거래 최대 수익률 상한
MIN_SINGLE_PNL = -50.0  # 단일 거래 최대 손실률 하한

for p in pnls:
    clamped_pnl = max(MIN_SINGLE_PNL, min(MAX_SINGLE_PNL, p))  # ⚠️ 클램핑!
    clamped_trades.append({'pnl': clamped_pnl})

max_drawdown = calculate_mdd(clamped_trades)  # ⚠️ 클램핑된 데이터로 MDD 계산
```

**결과**:
- Optimizer MDD: 18.80% (클램핑 O)
- 검증 스크립트 MDD: 6.30% (클램핑 X)
- **차이: -66%** (재현 불가능!)

### SSOT 원칙 위반

| 코드 경로 | 함수 호출 | 입력 데이터 | MDD 결과 |
|-----------|-----------|-------------|----------|
| `core/optimizer.py:1429` | `calculate_mdd(clamped_trades)` | **클램핑 O** | 18.80% |
| `utils/metrics.py:133` | `calculate_mdd(trades)` | **클램핑 X** | 6.30% |

→ **동일한 함수, 다른 입력 = SSOT 위반**

---

## 🛠️ 해결 방안 (Solution Options)

### Option A: 클램핑 완전 제거 ⭐ **권장**

**방식**: `core/optimizer.py`에서 PnL 클램핑 로직을 완전히 제거

**장점**:
- ✅ SSOT 원칙 준수 (입력 데이터 통일)
- ✅ 재현 가능성 100% (검증 스크립트와 동일 결과)
- ✅ 코드 단순화 (클램핑 로직 26줄 삭제)
- ✅ 실제 PnL 그대로 사용 (정확한 위험 측정)

**단점**:
- ⚠️ 복리 계산 시 오버플로우 가능성 (극단적 레버리지 매매)
  - **완화**: `compound_return` 계산 시 overflow 보호 유지
  - 예: `equity = max(0, min(equity, 1e10))`

**영향**:
- Optimizer MDD 18.80% → 6.30% (-66%, 정확한 값으로 수정)
- 기존 프리셋 무효화 (재최적화 필요)
- 테스트 수정 필요 (1개 파일)

**작업량**: 2-3시간

---

### Option B: 검증 스크립트에도 클램핑 적용

**방식**: `utils/metrics.py`에 클램핑 옵션 추가

**장점**:
- ✅ 일관성 확보 (양쪽 모두 클램핑 적용)

**단점**:
- ❌ SSOT 원칙 위반 (파라미터로 분기)
- ❌ 실제 PnL 왜곡 (위험 과대평가)
- ❌ 코드 복잡도 증가 (클램핑 플래그 관리)
- ❌ 근본 문제 미해결 (왜 클램핑이 필요한지?)

**작업량**: 1-2시간

**결론**: ❌ **비권장** (문제 회피에 불과)

---

### Option C: Optimizer가 `utils.metrics` 직접 호출 ⭐⭐ **최선**

**방식**: `core/optimizer.py`의 메트릭 계산 로직을 완전히 제거하고 `utils.metrics.calculate_backtest_metrics()` 호출

**장점**:
- ✅ **완벽한 SSOT** (코드 중복 0%)
- ✅ 재현 가능성 100%
- ✅ 코드 중복 제거 (~80줄 삭제)
- ✅ 유지보수 용이 (메트릭 로직 단일 위치)

**단점**:
- ⚠️ 대규모 리팩토링 필요 (optimizer.py 400줄 영향)
- ⚠️ 테스트 수정 필요 (3개 파일)

**작업량**: 4-6시간

**결론**: ✅ **이상적이지만 시간 고려 시 Phase 2로 연기 가능**

---

## 📌 권장 접근법 (Recommended Approach)

### Phase 1: 즉시 수정 (Option A) - 3시간

**클램핑 완전 제거**로 **재현성 문제 해결**

### Phase 2: 장기 개선 (Option C) - 미래 작업

**Optimizer 리팩토링**으로 **SSOT 완전 달성**

---

## 🗂️ 구현 계획 (Implementation Plan)

### Phase 1: PnL 클램핑 제거 (Option A)

#### Track 1: 클램핑 로직 제거 (60분)

**파일**: `core/optimizer.py`

**작업**:
1. **PnL 클램핑 제거** (라인 1404-1426)
   ```python
   # ❌ 삭제: MAX_SINGLE_PNL, MIN_SINGLE_PNL 상수
   # ❌ 삭제: clamped_pnl 계산 루프
   # ✅ 변경: calculate_mdd(trades) 호출 (클램핑 X)
   ```

2. **복리 계산 오버플로우 보호 유지**
   ```python
   # ✅ 유지: compound_return 범위 제한
   compound_return = max(-100.0, min(compound_return, 1e10))

   # ✅ 유지: equity 음수 방지
   if equity <= 0: equity = 0
   ```

3. **코드 정리**
   - 주석 업데이트 (클램핑 관련 주석 제거)
   - 변수명 정리 (`clamped_trades` → `trades`)

**검증 기준**:
- Pyright 에러 0개 유지
- 함수 시그니처 변경 없음 (하위 호환성)

---

#### Track 2: 테스트 수정 (40분)

**파일**: `tests/test_optimizer_core.py`

**작업**:
1. **MDD 예상값 수정**
   ```python
   # Before: expected_mdd = 18.80 (클램핑 O)
   # After: expected_mdd = 6.30 (클램핑 X)
   ```

2. **엣지 케이스 추가**
   - 단일 PnL > 50% 거래 테스트
   - 단일 PnL < -50% 거래 테스트
   - 극단적 레버리지 시나리오 (±100% PnL)

3. **재현성 테스트 강화**
   ```python
   def test_metric_reproducibility():
       """동일 데이터로 2회 실행 시 결과 일치 검증"""
       result1 = optimizer.run_backtest(df, params)
       result2 = optimizer.run_backtest(df, params)

       assert abs(result1['mdd'] - result2['mdd']) < 0.01  # ±1% 이내
       assert abs(result1['sharpe'] - result2['sharpe']) < 0.02  # ±2% 이내
   ```

**검증 기준**:
- 테스트 통과율 100%
- 재현성 테스트 추가 (±1% MDD, ±2% Sharpe)

---

#### Track 3: 검증 및 문서화 (60분)

**작업**:
1. **검증 스크립트 실행**
   ```bash
   # 동일한 프리셋으로 2회 테스트
   python tools/verify_preset_backtest.py \
       --preset presets/bybit_BTCUSDT_1h_macd_20260117_235704.json \
       --compare-optimizer
   ```

2. **결과 비교**
   | 지표 | Optimizer | 검증 스크립트 | 차이 | 허용 범위 |
   |------|-----------|---------------|------|-----------|
   | MDD | ? | 6.30% | ? | ✅ ±1% |
   | 승률 | ? | 90.02% | ? | ✅ ±5% |
   | Sharpe | ? | 25.03 | ? | ✅ ±5% |

3. **CLAUDE.md 업데이트**
   - Phase 1-D 섹션 추가: "메트릭 재현성 보장"
   - PnL 클램핑 제거 이력 기록
   - 재현성 검증 기준 명시 (±1% MDD, ±2% Sharpe)

4. **WORK_LOG 기록**
   ```text
   ## Phase 1-D: 메트릭 재현성 문제 해결
   - PnL 클램핑 제거 (core/optimizer.py, -26줄)
   - MDD 재현성: -66% → ±1% (+98% 개선)
   - 테스트 강화: 재현성 검증 추가
   ```

**검증 기준**:
- MDD 차이 ±1% 이내
- 승률 차이 ±5% 이내
- Sharpe 차이 ±5% 이내

---

### Phase 2: SSOT 완전 달성 (Option C) - 미래 작업

**범위**: `core/optimizer.py` → `utils.metrics` 완전 위임

**작업**:
1. `calculate_backtest_metrics()` 파라미터 확장
   - `use_clamping: bool = False` 옵션 추가 (하위 호환성)
   - `max_single_pnl: float | None = None` 옵션 추가

2. `optimizer.py` 메트릭 계산 로직 제거
   - 라인 1404-1520 삭제 (~80줄)
   - `utils.metrics.calculate_backtest_metrics()` 호출로 교체

3. 테스트 수정
   - `test_optimizer_core.py` 예상값 업데이트
   - `test_metrics.py` 클램핑 옵션 테스트 추가

**예상 소요 시간**: 4-6시간
**우선순위**: P2 (Phase 1 완료 후 진행)

---

## 🎯 검증 기준 (Success Criteria)

### 재현성 기준

| 지표 | 허용 오차 | 현재 상태 | 목표 상태 |
|------|-----------|-----------|-----------|
| **MDD** | ±1% | ❌ -66% | ✅ ±1% |
| **승률** | ±5% | ✅ +0.15% | ✅ 유지 |
| **Sharpe** | ±5% | ✅ -1.0% | ✅ 유지 |
| **PF** | ±5% | ✅ -1.6% | ✅ 유지 |

### 코드 품질 기준

- ✅ Pyright 에러 0개 유지
- ✅ 테스트 통과율 100%
- ✅ 코드 중복 -26줄 (클램핑 로직 제거)
- ✅ SSOT 원칙 준수 (입력 데이터 통일)

---

## 📊 예상 성과 (Expected Outcome)

### 정량적 성과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| **MDD 재현성** | -66% | ±1% | **+98%** |
| **코드 중복** | 26줄 | 0줄 | **-100%** |
| **SSOT 준수** | 50% | 100% | **+100%** |
| **테스트 커버리지** | 85% | 90% | **+6%** |

### 정성적 성과

- ✅ **최적화 신뢰성 회복**: 선택된 파라미터가 실제로 최적임을 보장
- ✅ **프리셋 신뢰성 확보**: 저장된 MDD가 정확한 값
- ✅ **SSOT 원칙 강화**: 동일 함수 = 동일 결과
- ✅ **디버깅 용이성**: 재현 불가능한 버그 제거

---

## ⚠️ 위험 요소 (Risks)

### Risk 1: 기존 프리셋 무효화

**위험도**: 🟡 중간
**영향**: 저장된 프리셋의 MDD 값이 부정확 (18.8% → 실제 6.3%)
**완화**:
- 프리셋 재생성 스크립트 제공 (`tools/regenerate_presets.py`)
- 사용자에게 프리셋 재최적화 권장 메시지 표시

### Risk 2: 오버플로우 가능성

**위험도**: 🟢 낮음
**영향**: 극단적 레버리지 매매 시 `compound_return` 오버플로우
**완화**:
- `compound_return` 범위 제한 유지 (`-100% ~ 1e10%`)
- `equity` 음수 방지 (`if equity <= 0: equity = 0`)

### Risk 3: 테스트 실패

**위험도**: 🟢 낮음
**영향**: MDD 예상값 변경으로 기존 테스트 실패
**완화**:
- 테스트 데이터 재생성
- 예상값 업데이트 (`18.80% → 6.30%`)

---

## 📅 작업 일정 (Timeline)

### Day 1: Phase 1 완료 (3시간)

| 시간 | 작업 | 담당 |
|------|------|------|
| 0-60분 | Track 1: 클램핑 로직 제거 | Claude |
| 60-100분 | Track 2: 테스트 수정 | Claude |
| 100-180분 | Track 3: 검증 및 문서화 | Claude |

### Day 2+: Phase 2 (미래 작업, 4-6시간)

- SSOT 완전 달성 (Optimizer → utils.metrics 위임)
- 우선순위: P2 (Phase 1 완료 후 검토)

---

## 🔧 구현 세부사항 (Implementation Details)

### 수정 파일 목록

| 파일 | 변경 내용 | 라인 수 |
|------|-----------|---------|
| `core/optimizer.py` | PnL 클램핑 제거 | -26줄 |
| `tests/test_optimizer_core.py` | MDD 예상값 수정 + 재현성 테스트 추가 | +30줄 |
| `CLAUDE.md` | Phase 1-D 섹션 추가 | +50줄 |
| `docs/WORK_LOG_20260117.txt` | 작업 이력 기록 | +20줄 |

**총 변경**: +74줄, -26줄

---

### 코드 변경 예시

#### Before (core/optimizer.py:1404-1429)

```python
# [FIX] 단일 거래 PnL 상한선 적용 (±50%) - 오버플로우 방지
MAX_SINGLE_PNL = 50.0
MIN_SINGLE_PNL = -50.0

equity = 1.0
cumulative_equity = [1.0]
for p in pnls:
    clamped_pnl = max(MIN_SINGLE_PNL, min(MAX_SINGLE_PNL, p))  # ❌ 클램핑
    equity *= (1 + clamped_pnl / 100)
    if equity <= 0: equity = 0
    cumulative_equity.append(equity)
    if equity == 0: break

compound_return = (equity - 1) * 100
compound_return = max(-100.0, min(compound_return, 1e10))

# MDD 계산
clamped_trades = []
for p in pnls:
    clamped_pnl = max(MIN_SINGLE_PNL, min(MAX_SINGLE_PNL, p))  # ❌ 클램핑
    clamped_trades.append({'pnl': clamped_pnl})

max_drawdown = calculate_mdd(clamped_trades)  # ❌ 클램핑된 데이터
```

#### After (core/optimizer.py:1404-1420)

```python
# 1. 누적 수익률 (Compound/Equity) 계산
equity = 1.0
cumulative_equity = [1.0]
for p in pnls:
    equity *= (1 + p / 100)  # ✅ 원본 PnL 사용
    if equity <= 0: equity = 0  # 음수 방지 (유지)
    cumulative_equity.append(equity)
    if equity == 0: break

compound_return = (equity - 1) * 100
compound_return = max(-100.0, min(compound_return, 1e10))  # 오버플로우 보호 (유지)

# 2. MDD 계산 - SSOT 사용
trades_for_mdd = [{'pnl': p} for p in pnls]  # ✅ 원본 PnL 사용
max_drawdown = calculate_mdd(trades_for_mdd)  # ✅ 클램핑 X
```

**변경 요약**:
- 클램핑 로직 26줄 삭제
- 원본 PnL 사용 (재현성 100%)
- 오버플로우 보호는 유지 (복리 계산만)

---

## 📚 참고 문서 (References)

1. **문제 보고서**: `docs/BACKTEST_METRIC_DISCREPANCY_REPORT.md`
2. **SSOT 원칙**: `CLAUDE.md` v7.23, Phase 1-B
3. **메트릭 모듈**: `utils/metrics.py`
4. **Optimizer 코어**: `core/optimizer.py`
5. **검증 스크립트**: `tools/verify_preset_backtest.py`

---

## ✅ 체크리스트 (Checklist)

### 구현 전 확인

- [ ] 기존 테스트 실행 (현재 상태 확인)
- [ ] 검증 스크립트 실행 (MDD 차이 확인: -66%)
- [ ] Git 브랜치 생성 (`feat/fix-metric-reproducibility`)

### 구현 중 확인

- [ ] Track 1: PnL 클램핑 제거 완료
- [ ] Track 2: 테스트 수정 완료
- [ ] Track 3: 검증 완료 (MDD 차이 ±1% 이내)
- [ ] Pyright 에러 0개 유지

### 구현 후 확인

- [ ] 테스트 통과율 100%
- [ ] 재현성 검증 (동일 데이터로 2회 실행)
- [ ] 문서화 완료 (CLAUDE.md, WORK_LOG)
- [ ] 프리셋 재생성 스크립트 작성

---

## 🎓 학습 포인트 (Lessons Learned)

### SSOT 원칙의 중요성

**문제**: 동일한 함수를 호출하지만 **입력 데이터가 다르면** SSOT 위반
**교훈**: 함수 호출뿐 아니라 **입력 데이터도 통일**해야 함

### 재현성의 가치

**문제**: MDD -66% 차이 → 최적화 결과 신뢰 불가
**교훈**: **재현 가능성**이 없으면 디버깅, 검증, 신뢰 모두 불가능

### 방어적 프로그래밍의 부작용

**문제**: "오버플로우 방지" 클램핑이 **부작용** 초래
**교훈**: 방어 코드는 **최소 범위**에만 적용 (복리 계산만, MDD는 제외)

---

## 🚀 다음 단계 (Next Steps)

### Phase 1 완료 후

1. **프리셋 재생성**: 저장된 프리셋의 MDD 값 업데이트
2. **사용자 공지**: "MDD 계산 방식 개선" 릴리스 노트 작성
3. **Phase 2 검토**: SSOT 완전 달성 계획 승인

### Phase 2 (미래 작업)

1. **Optimizer 리팩토링**: 메트릭 계산을 `utils.metrics`로 완전 위임
2. **클램핑 옵션 추가**: `calculate_backtest_metrics(use_clamping=False)`
3. **성능 최적화**: 중복 계산 제거 (~80줄 삭제)

---

## 📞 승인 요청 (Approval Request)

**계획서 검토 완료 후 다음 단계로 진행하시겠습니까?**

- [ ] **Phase 1 즉시 시작** (PnL 클램핑 제거, 3시간)
- [ ] **수정 요청** (계획서 보완 필요)
- [ ] **Phase 2로 전환** (SSOT 완전 달성, 4-6시간)

---

**작성**: Claude Opus 4.5
**일자**: 2026-01-17
**문서 버전**: v1.0
