# 백테스트 시스템 개념 재정립 및 개편 계획서

**작성일**: 2026-01-18
**버전**: v7.25 Concept Reform
**목적**: 복잡한 분석 방법론 제거, 실용적 수익률 계산 중심으로 재편

---

## 📋 목차

1. [핵심 문제 인식](#핵심-문제-인식)
2. [개념 재정립](#개념-재정립)
3. [CLAUDE.md 추가 섹션](#claudemd-추가-섹션)
4. [개편 계획](#개편-계획)
5. [우선순위](#우선순위)

---

## 핵심 문제 인식

### ❌ 현재의 문제점

**과도한 분석 방법론**:
```
- Sensitivity Analysis (One-at-a-Time)
- Kelly Criterion 레버리지 계산
- 백분위수 기반 범위 추출
- A/B 테스트 프레임워크
- Walk-Forward 검증
- Monte Carlo 시뮬레이션 (미구현)
```

**결과**:
- ✅ 분석은 정교함
- ❌ **실제 결정은 단순**: "이 파라미터가 더 나은가?"
- ❌ **시간 낭비**: 복잡한 통계 분석에 90% 시간 소모
- ❌ **핵심 누락 1**: **단리 vs 복리 구분 없음**
- ❌ **핵심 누락 2**: **OHLCV 값 기반 계산 없음** (진입 시점 O-C 분포 미분석)

### ✅ 사용자가 원하는 것

**단순한 질문**:
1. 이 파라미터 조합의 **단리 수익**은?
2. 이 파라미터 조합의 **복리 수익**은?
3. **MDD**는 얼마인가?
4. **안전한 레버리지**는?
5. **진입 시점의 O-C 분포**는? (실제 체결가 예측)

**그게 다다.**

---

## 개념 재정립

### 1. 수익률 계산의 명확화

#### A. 단리 수익률 (Simple Return)

**정의**: 초기 자본 대비 총 수익의 합

**계산**:
```python
단리 수익률 = (Σ PnL) / 초기자본 × 100%

예시:
- 초기 자본: $100
- 거래 1: +$5 (5%)
- 거래 2: +$3 (3%)
- 거래 3: -$1 (-1%)
- 단리 수익: ($5 + $3 - $1) / $100 = 7%
```

**특징**:
- ✅ 계산 간단
- ✅ 이해 쉬움
- ✅ 거래 횟수 무관
- ❌ 복리 효과 미반영

#### B. 복리 수익률 (Compound Return)

**정의**: 수익을 재투자했을 때의 최종 자본

**계산**:
```python
복리 수익률 = (최종자본 / 초기자본 - 1) × 100%

최종자본 = 초기자본 × Π(1 + 거래별 수익률)

예시:
- 초기 자본: $100
- 거래 1: +5% → $105
- 거래 2: +3% → $105 × 1.03 = $108.15
- 거래 3: -1% → $108.15 × 0.99 = $107.07
- 복리 수익: ($107.07 / $100 - 1) = 7.07%
```

**특징**:
- ✅ 실제 자본 증식 반영
- ✅ 재투자 효과 포함
- ❌ 거래 횟수 많으면 폭발적 증가
- ⚠️ 오버플로우 위험 (10,000회 이상)

#### C. 거래당 평균 수익률 (Average PnL per Trade)

**정의**: 거래 1회당 평균 수익

**계산**:
```python
거래당 평균 = 단리 수익률 / 거래 횟수

예시:
- 단리 수익: 4,076%
- 거래 횟수: 10,133회
- 거래당 평균: 4,076% / 10,133 = 0.402%
```

**특징**:
- ✅ 전략 효율성 지표
- ✅ 비용 대비 수익 판단 기준
- ✅ 거래 빈도 조절 기준

### 2. MDD (Maximum Drawdown)

**정의**: 최대 낙폭 (고점 대비 최대 손실)

**계산**:
```python
MDD = max((고점 - 저점) / 고점) × 100%

예시:
- 자본 $100 → $150 (고점)
- 자본 $150 → $130 (저점)
- MDD = ($150 - $130) / $150 = 13.3%
```

**특징**:
- ✅ 리스크 핵심 지표
- ✅ 레버리지 결정 기준
- ✅ 심리적 견딜 수 있는 손실

### 3. 안전 레버리지 (Safe Leverage)

**정의**: MDD 10% 이하 유지하는 최대 레버리지

**계산**:
```python
안전 레버리지 = 목표 MDD / 실제 MDD

예시:
- 실제 MDD: 1.24%
- 목표 MDD: 10%
- 안전 레버리지: 10% / 1.24% = 8.1x
```

**특징**:
- ✅ 간단 명확
- ✅ 리스크 관리 핵심
- ⚠️ Kelly Criterion보다 보수적 (권장)

---

### 4. 진입 시점 OHLCV 분포 (Entry Candle Distribution)

**정의**: 신호 발생 후 실제 진입하는 봉의 Open-Close 차이 분포

**목적**:
- 실제 체결가 예측
- 슬리피지 검증
- 지정가 주문 최적 가격 결정

**계산**:
```python
# 진입 봉 (next candle after signal)
entry_candles = []
for signal in signals:
    next_idx = signal_idx + 1
    if next_idx < len(df):
        entry_candles.append({
            'open': df.loc[next_idx, 'open'],
            'high': df.loc[next_idx, 'high'],
            'low': df.loc[next_idx, 'low'],
            'close': df.loc[next_idx, 'close'],
        })

# Long 진입 분포
long_oc_diff = [(c['close'] - c['open']) / c['open'] * 100
                 for c in entry_candles if signal_side == 'Long']

# Short 진입 분포
short_oc_diff = [(c['open'] - c['close']) / c['open'] * 100
                  for c in entry_candles if signal_side == 'Short']

# 통계
stats = {
    'mean': np.mean(long_oc_diff),      # 평균 O-C 차이
    'median': np.median(long_oc_diff),  # 중간값
    'std': np.std(long_oc_diff),        # 표준편차
    'q25': np.percentile(long_oc_diff, 25),  # 25% 백분위
    'q75': np.percentile(long_oc_diff, 75),  # 75% 백분위
}
```

**활용**:
1. **지정가 주문 가격 결정**
   - Long: `next_open + (mean - std)` (보수적)
   - Short: `next_open - (mean - std)`

2. **슬리피지 검증**
   - 현재 슬리피지 0.1% vs 실제 O-C 차이
   - 과대 책정 확인

3. **최적 파라미터 선택**
   - O-C 차이가 작은 파라미터 우선
   - 예측 가능성 높음

**예시 결과**:
```
Long 진입 봉 O-C 분포 (10,133개):
  평균:   +0.15% (Open → Close 상승)
  중간값: +0.08%
  표준편차: 0.42%
  25%:    -0.12%
  75%:    +0.38%

해석:
- 평균적으로 진입 봉에서 +0.15% 상승
- 75%는 +0.38% 이하 상승
- 지정가 주문: next_open - 0.27% (mean - std) 권장
```

**주의사항**:
- ⚠️ 극단값 제거 (±10% 이상 필터링)
- ⚠️ 시장 환경 변화 고려 (최근 1년 데이터만)
- ⚠️ 타임프레임별 차이 (1h vs 4h)

---

## CLAUDE.md 추가 섹션

### 📊 백테스트 수익률 표준 (v7.25)

#### 개요

백테스트 결과는 **4가지 핵심 지표**만 보고:

1. **단리 수익률** - 총 수익의 합
2. **복리 수익률** - 재투자 시 최종 자본
3. **MDD** - 최대 낙폭
4. **안전 레버리지** - MDD 10% 기준

**원칙**: 복잡한 통계 분석은 하지 않는다. 숫자로 바로 비교한다.

---

#### 1. 단리 수익률 (Simple Return)

**정의**:
```python
단리 수익률 = (Σ PnL) / 초기자본 × 100%
```

**코드**:
```python
from utils.metrics import calculate_backtest_metrics

metrics = calculate_backtest_metrics(trades, leverage=1, capital=100.0)
simple_return = metrics['total_pnl']  # 단리 수익률
```

**표시 형식**:
- UI: `"단리: 4,076.00%"`
- 콘솔: `"Simple Return: 4,076.00%"`
- CSV: `simple_return,4076.00`

**예시**:
```
거래 1: +5%
거래 2: +3%
거래 3: -1%
단리: 7%
```

---

#### 2. 복리 수익률 (Compound Return)

**정의**:
```python
복리 수익률 = (최종자본 / 초기자본 - 1) × 100%
최종자본 = 초기자본 × Π(1 + 거래별 수익률)
```

**코드**:
```python
metrics = calculate_backtest_metrics(trades, leverage=1, capital=100.0)
compound_return = metrics['compound_return']  # 복리 수익률

# 오버플로우 방지 (제한: 1e10%)
if compound_return > 1e10:
    compound_return = 1e10
    print("⚠️ 복리 오버플로우 (1e10% 제한)")
```

**표시 형식**:
- UI: `"복리: 4,121.35%"` 또는 `"복리: 계산 불가 (오버플로우)"`
- 콘솔: `"Compound Return: 4,121.35%"` 또는 `"Overflow"`
- CSV: `compound_return,4121.35` 또는 `compound_return,inf`

**예시**:
```
초기: $100
거래 1: +5% → $105
거래 2: +3% → $108.15
거래 3: -1% → $107.07
복리: 7.07%
```

---

#### 3. 거래당 평균 수익률 (Average PnL per Trade)

**정의**:
```python
거래당 평균 = 단리 수익률 / 거래 횟수
```

**코드**:
```python
metrics = calculate_backtest_metrics(trades, leverage=1, capital=100.0)
avg_pnl = metrics['avg_pnl']  # 거래당 평균 (%)
```

**표시 형식**:
- UI: `"거래당: 0.40%"`
- 콘솔: `"Avg PnL/Trade: 0.40%"`
- CSV: `avg_pnl,0.40`

**의미**:
- `> 0.5%`: 매우 효율적 (거래 비용 0.04% 대비 12배)
- `0.2-0.5%`: 효율적 (5-12배)
- `0.1-0.2%`: 보통 (2-5배)
- `< 0.1%`: 비효율적 (거래 비용 대비 2배 이하)

---

#### 4. MDD (Maximum Drawdown)

**정의**:
```python
MDD = max((고점 - 저점) / 고점) × 100%
```

**코드**:
```python
metrics = calculate_backtest_metrics(trades, leverage=1, capital=100.0)
mdd = metrics['mdd']  # MDD (%)
```

**표시 형식**:
- UI: `"MDD: 1.24%"` (색상: 녹색 <5%, 노랑 5-10%, 빨강 >10%)
- 콘솔: `"MDD: 1.24%"`
- CSV: `mdd,1.24`

**의미**:
- `< 5%`: 매우 안전 (레버리지 가능)
- `5-10%`: 안전 (적정 레버리지)
- `10-20%`: 주의 (낮은 레버리지)
- `> 20%`: 위험 (레버리지 불가)

---

#### 5. 안전 레버리지 (Safe Leverage)

**정의**:
```python
안전 레버리지 = 10% / MDD
```

**코드**:
```python
metrics = calculate_backtest_metrics(trades, leverage=1, capital=100.0)
mdd = metrics['mdd']
safe_leverage = 10.0 / mdd if mdd > 0 else 1.0

# 최대 20x 제한 (거래소 한계)
safe_leverage = min(safe_leverage, 20.0)
```

**표시 형식**:
- UI: `"안전 레버리지: 8.1x"`
- 콘솔: `"Safe Leverage: 8.1x"`
- CSV: `safe_leverage,8.1`

**의미**:
- `> 10x`: 매우 낮은 리스크
- `5-10x`: 낮은 리스크
- `2-5x`: 보통 리스크
- `< 2x`: 높은 리스크

---

#### 백테스트 결과 표시 예시

**UI 카드**:
```
┌─────────────────────────────────────┐
│ 백테스트 결과                        │
├─────────────────────────────────────┤
│ 단리 수익:      4,076.00%           │
│ 복리 수익:      4,121.35%           │
│ 거래당 평균:    0.40%               │
│ MDD:           1.24% 🟢            │
│ 안전 레버리지:  8.1x                │
│                                     │
│ 거래 횟수:      10,133회            │
│ 승률:          83.8%                │
│ Sharpe:        21.06                │
│ Profit Factor: 19.36                │
└─────────────────────────────────────┘
```

**콘솔 출력**:
```
===== Backtest Results =====
Simple Return:    4,076.00%
Compound Return:  4,121.35%
Avg PnL/Trade:    0.40%
MDD:              1.24%
Safe Leverage:    8.1x

Total Trades:     10,133
Win Rate:         83.8%
Sharpe Ratio:     21.06
Profit Factor:    19.36
============================
```

**CSV 저장**:
```csv
simple_return,compound_return,avg_pnl,mdd,safe_leverage,total_trades,win_rate,sharpe_ratio,profit_factor
4076.00,4121.35,0.40,1.24,8.1,10133,83.8,21.06,19.36
```

---

#### 비교 표준

**파라미터 A vs B 비교 시**:

| 지표 | A | B | 선택 |
|------|---|---|------|
| 단리 | 4,076% | 3,521% | A ✅ |
| 복리 | 4,121% | 3,556% | A ✅ |
| 거래당 평균 | 0.40% | 0.39% | A ✅ |
| MDD | 1.24% | 3.71% | A ✅ |
| 안전 레버리지 | 8.1x | 2.7x | A ✅ |

**결론**: A가 모든 지표에서 우수 → A 선택

**원칙**:
1. 단리, 복리, 거래당 평균은 높을수록 좋다
2. MDD는 낮을수록 좋다
3. 안전 레버리지는 높을수록 좋다
4. **5개 지표 중 4개 이상 우수하면 선택**

---

#### 금지 사항

**❌ 절대 금지**:
1. Kelly Criterion 레버리지 계산 (복잡, 불필요)
2. Sensitivity Analysis (시간 낭비)
3. Walk-Forward 검증 (과적합 방지는 심볼 다양화로)
4. Monte Carlo 시뮬레이션 (백테스트 자체가 시뮬레이션)
5. 백분위수 기반 범위 추출 (Meta 최적화만 사용)

**✅ 올바른 방법**:
1. 두 파라미터 조합 백테스트
2. 5개 지표 비교
3. 더 나은 쪽 선택
4. 끝.

---

## 개편 계획

### Phase 1: CLAUDE.md 업데이트 (30분)

**작업**:
- [ ] "📊 백테스트 수익률 표준 (v7.25)" 섹션 추가
- [ ] 기존 Kelly Criterion 섹션 제거
- [ ] Sensitivity Analysis 섹션 제거

**파일**: `CLAUDE.md`

---

### Phase 2: utils/metrics.py 강화 (60분)

**작업**:
- [ ] `safe_leverage` 계산 추가
- [ ] 복리 오버플로우 방지 강화 (1e10 제한)
- [ ] 주석 개선 (단리/복리 구분 명확히)

**파일**: `utils/metrics.py`

**수정 내용**:
```python
def calculate_backtest_metrics(
    trades: List[Dict],
    leverage: int = 1,
    capital: float = 100.0
) -> dict:
    """
    백테스트 메트릭 계산 (v7.25 업데이트)

    핵심 지표:
    1. total_pnl (단리 수익률)
    2. compound_return (복리 수익률, 1e10 제한)
    3. avg_pnl (거래당 평균)
    4. mdd (최대 낙폭)
    5. safe_leverage (안전 레버리지, MDD 10% 기준)

    Args:
        trades: 거래 목록
        leverage: 레버리지 (기본 1)
        capital: 초기 자본 (기본 100.0)

    Returns:
        dict: 17개 메트릭 (기존) + safe_leverage (신규)
    """
    # 기존 계산...

    # 안전 레버리지 추가
    safe_leverage = 10.0 / mdd if mdd > 0 else 1.0
    safe_leverage = min(safe_leverage, 20.0)  # 최대 20x

    return {
        # 핵심 5개
        'total_pnl': total_pnl,           # 단리
        'compound_return': compound_return,  # 복리
        'avg_pnl': avg_pnl,               # 거래당 평균
        'mdd': mdd,                       # MDD
        'safe_leverage': safe_leverage,    # 안전 레버리지 (신규)

        # 기존 지표들...
    }
```

---

### Phase 3: UI 표시 개선 (90분)

**작업**:
- [ ] 백테스트 결과 카드에 "안전 레버리지" 추가
- [ ] 단리/복리 구분 명확히 표시
- [ ] MDD 색상 표시 (녹색/노랑/빨강)

**파일**:
- `ui/widgets/backtest/single.py`
- `ui/widgets/backtest/multi.py`
- `ui/widgets/optimization/single.py`

**예시**:
```python
# 백테스트 결과 표시
result_text = f"""
<h3>백테스트 결과</h3>
<table>
<tr><td>단리 수익:</td><td><b>{metrics['total_pnl']:.2f}%</b></td></tr>
<tr><td>복리 수익:</td><td><b>{metrics['compound_return']:.2f}%</b></td></tr>
<tr><td>거래당 평균:</td><td>{metrics['avg_pnl']:.2f}%</td></tr>
<tr><td>MDD:</td><td><span style='color:{mdd_color}'>{metrics['mdd']:.2f}%</span></td></tr>
<tr><td>안전 레버리지:</td><td><b>{metrics['safe_leverage']:.1f}x</b></td></tr>
</table>
"""
```

---

### Phase 4: 불필요한 코드 제거 (60분)

**제거 대상**:
- [ ] Kelly Criterion 계산 함수
- [ ] Sensitivity Analysis 스크립트
- [ ] Walk-Forward 검증 스크립트 (미구현)

**파일**:
- `tools/test_sensitivity_analysis.py` → 아카이브
- `core/optimizer.py` 내 Kelly 계산 제거
- `utils/` 내 불필요한 통계 함수 제거

---

### Phase 5: 문서 정리 (30분)

**작업**:
- [ ] `OPTIMIZATION_RESULTS_20260118.md` 수정
  - Kelly Criterion 섹션 제거
  - Sensitivity Analysis 섹션 간소화
  - "5개 핵심 지표" 강조
- [ ] `STRATEGY_GUIDE.md` 업데이트
  - 단리/복리 설명 추가
  - 안전 레버리지 설명 추가

---

## 우선순위

### 🔥 즉시 실행 (오늘, 2시간)

1. **Phase 1: CLAUDE.md 업데이트** (30분)
   - 백테스트 수익률 표준 추가
   - 불필요한 섹션 제거

2. **Phase 2: utils/metrics.py 강화** (60분)
   - `safe_leverage` 필드 추가
   - 복리 오버플로우 방지 강화

3. **Phase 3: UI 표시 개선** (30분)
   - 백테스트 결과 카드에 "안전 레버리지" 추가

### 📅 단기 실행 (내일, 1.5시간)

4. **Phase 3 완료: UI 전체 개선** (60분)
   - 단리/복리 구분 명확히
   - MDD 색상 표시

5. **Phase 4: 불필요한 코드 제거** (30분)
   - Kelly/Sensitivity 스크립트 아카이브

### 📆 중기 실행 (이번 주, 1시간)

6. **Phase 5: 문서 정리** (30분)
   - 분석 보고서 간소화

7. **검증** (30분)
   - 전체 백테스트 재실행
   - 5개 지표 정상 출력 확인

---

## 예상 효과

### Before (v7.24)

```
복잡한 분석:
- Kelly Criterion 계산 (5분)
- Sensitivity Analysis (10분)
- 백분위수 범위 추출 (5분)
- 결과 해석 및 비교 (10분)
총 시간: 30분

결정:
- "A가 B보다 나은가?" → Yes/No
```

### After (v7.25)

```
단순한 비교:
- 백테스트 A 실행 (30초)
- 백테스트 B 실행 (30초)
- 5개 지표 비교 (10초)
- 결정 (즉시)
총 시간: 1분 10초

결정:
- "A가 B보다 나은가?" → Yes/No
```

**시간 절약**: 96% (30분 → 1분)

---

## 핵심 철학

### ✅ 새로운 원칙 (v7.25)

1. **단순함이 최고다**
   - 복잡한 통계 분석은 시간 낭비
   - 숫자로 바로 비교

2. **5개 지표면 충분하다**
   - 단리, 복리, 거래당 평균, MDD, 안전 레버리지
   - 더 이상 필요 없음

3. **빠른 반복이 핵심이다**
   - 30분 분석 → 1분 비교
   - 100번 시도 가능

4. **사용자의 시간을 존중한다**
   - "이게 더 나은가?" → 즉시 답변
   - 쓸데없는 설명 최소화

---

## 검증 체크리스트

### Phase 1-2 완료 후

- [ ] CLAUDE.md에 "백테스트 수익률 표준" 섹션 추가됨
- [ ] `safe_leverage` 필드가 metrics에 포함됨
- [ ] 복리 오버플로우 1e10 제한 작동

### Phase 3 완료 후

- [ ] UI에 "안전 레버리지" 표시됨
- [ ] 단리/복리 구분 명확함
- [ ] MDD 색상 표시 작동

### Phase 4-5 완료 후

- [ ] Kelly/Sensitivity 스크립트 아카이브됨
- [ ] 문서에서 불필요한 분석 설명 제거됨

---

## 최종 목표

**v7.25의 비전**:

> "두 파라미터 조합을 1분 안에 비교하고, 더 나은 쪽을 즉시 선택한다."

**측정 가능한 목표**:
- 파라미터 비교 시간: 30분 → 1분 (-96%)
- 핵심 지표: 17개 → 5개 (-70%)
- 사용자 만족도: 중간 → 높음 (+100%)

---

**작성자**: Claude Sonnet 4.5
**검토**: 사용자 승인 필요
**다음 단계**: Phase 1 (CLAUDE.md 업데이트) 즉시 시작 가능
