"""
간단한 Bybit BTC 백테스트
Python 환경 문제 우회용
"""
import pandas as pd
import numpy as np
from pathlib import Path
import json
from datetime import datetime

# 프로젝트 루트
project_root = Path(__file__).parent.parent

print("=" * 80)
print("Bybit BTC/USDT 백테스트 (간단 버전)")
print("=" * 80)

# 1. 데이터 로드
print("\n[1/3] 데이터 로드...")
parquet_path = project_root / "data" / "cache" / "bybit_btcusdt_15m.parquet"

try:
    df = pd.read_parquet(parquet_path)
    print(f"[OK] Total {len(df):,} candles")
    print(f"     Period: {df['timestamp'].min()} ~ {df['timestamp'].max()}")
except Exception as e:
    print(f"[ERROR] {e}")
    exit(1)

# 2. 지표 계산 (간단 버전)
print("\n[2/3] 지표 계산...")

# RSI 계산
def calculate_simple_rsi(close, period=14):
    delta = close.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

# ATR 계산
def calculate_simple_atr(high, low, close, period=14):
    tr1 = high - low
    tr2 = abs(high - close.shift())
    tr3 = abs(low - close.shift())
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(window=period).mean()
    return atr

df['rsi'] = calculate_simple_rsi(df['close'], period=14)
df['atr'] = calculate_simple_atr(df['high'], df['low'], df['close'], period=14)

print(f"[OK] RSI, ATR 계산 완료")

# 3. 백테스트 (초간단 버전)
print("\n[3/3] 백테스트 실행...")

# 파라미터 (매우 보수적 설정)
RSI_LOW = 20  # 과매도 극단
RSI_HIGH = 80  # 과매수 극단
LEVERAGE = 2  # 레버리지 매우 낮춤 (3 → 2)
CAPITAL = 100  # $100 시작
STOP_LOSS_PCT = 0.03  # 3% 손절 (여유 있게)
TAKE_PROFIT_PCT = 0.05  # 5% 익절 추가

# 거래 기록
trades = []
position = None  # None or {'entry_price', 'side', 'size'}
equity_curve = [CAPITAL]

for i in range(100, len(df)):  # 처음 100개는 지표 워밍업
    row = df.iloc[i]
    current_price = row['close']
    rsi = row['rsi']
    atr = row['atr']

    # NaN 체크
    if pd.isna(rsi) or pd.isna(atr):
        continue

    # 포지션 없을 때 - 진입 신호 확인
    if position is None:
        # Long 진입 (RSI < 30)
        if rsi < RSI_LOW:
            position = {
                'entry_price': current_price,
                'side': 'Long',
                'size': 0.01,  # 0.01 BTC
                'entry_idx': i
            }

        # Short 진입 (RSI > 70)
        elif rsi > RSI_HIGH:
            position = {
                'entry_price': current_price,
                'side': 'Short',
                'size': 0.01,
                'entry_idx': i
            }

    # 포지션 있을 때 - 청산 신호 확인
    else:
        exit_condition = False

        if position['side'] == 'Long':
            # Long 청산: RSI > 55 or 3% 손절 or 5% 익절
            if (rsi > 55 or
                current_price < position['entry_price'] * (1 - STOP_LOSS_PCT) or
                current_price > position['entry_price'] * (1 + TAKE_PROFIT_PCT)):
                exit_condition = True

        else:  # Short
            # Short 청산: RSI < 45 or 3% 손절 or 5% 익절
            if (rsi < 45 or
                current_price > position['entry_price'] * (1 + STOP_LOSS_PCT) or
                current_price < position['entry_price'] * (1 - TAKE_PROFIT_PCT)):
                exit_condition = True

        # 청산 실행
        if exit_condition:
            entry_price = position['entry_price']
            exit_price = current_price
            size = position['size']

            # PnL 계산 (%)
            if position['side'] == 'Long':
                pnl_pct = (exit_price - entry_price) / entry_price * LEVERAGE * 100
            else:
                pnl_pct = (entry_price - exit_price) / entry_price * LEVERAGE * 100

            # 수수료 (0.1% × 2)
            fee_pct = 0.1 * 2
            pnl_pct -= fee_pct

            # 거래 기록
            trades.append({
                'entry_price': entry_price,
                'exit_price': exit_price,
                'side': position['side'],
                'pnl_pct': pnl_pct,
                'entry_idx': position['entry_idx'],
                'exit_idx': i
            })

            # Equity 갱신
            new_equity = equity_curve[-1] * (1 + pnl_pct / 100)
            equity_curve.append(new_equity)

            # 포지션 초기화
            position = None

# 결과 계산
print(f"\n[OK] 백테스트 완료")

if len(trades) == 0:
    print("[ERROR] 거래가 발생하지 않았습니다.")
else:
    # 승률
    wins = [t for t in trades if t['pnl_pct'] > 0]
    win_rate = len(wins) / len(trades) * 100

    # 총 수익률
    total_pnl = sum(t['pnl_pct'] for t in trades)

    # MDD
    peak = equity_curve[0]
    max_dd = 0
    for equity in equity_curve:
        if equity > peak:
            peak = equity
        dd = (peak - equity) / peak * 100
        if dd > max_dd:
            max_dd = dd

    # 최종 자본
    final_capital = equity_curve[-1]

    # Profit Factor
    gains = sum(t['pnl_pct'] for t in trades if t['pnl_pct'] > 0)
    losses = abs(sum(t['pnl_pct'] for t in trades if t['pnl_pct'] < 0))
    profit_factor = gains / losses if losses > 0 else gains

    print(f"\n[백테스트 결과]")
    print(f"   총 거래 수: {len(trades)}회")
    print(f"   승리 거래: {len(wins)}회")
    print(f"   승률: {win_rate:.2f}%")
    print(f"   총 수익률: {total_pnl:.2f}%")
    print(f"   최대 낙폭 (MDD): {max_dd:.2f}%")
    print(f"   Profit Factor: {profit_factor:.2f}")
    print(f"   최종 자본: ${final_capital:.2f} (시작: ${CAPITAL})")
    print(f"   복리 수익률: {(final_capital - CAPITAL) / CAPITAL * 100:.2f}%")

    # 프리셋 저장
    preset_name = f"bybit_btc_simple_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

    preset_data = {
        'name': preset_name,
        'exchange': 'bybit',
        'symbol': 'BTCUSDT',
        'timeframe': '15m',
        'params': {
            'rsi_period': 14,
            'rsi_low': RSI_LOW,
            'rsi_high': RSI_HIGH,
            'atr_period': 14,
            'leverage': LEVERAGE
        },
        'backtest_result': {
            'total_trades': len(trades),
            'win_rate': win_rate,
            'total_return': total_pnl,
            'max_drawdown': max_dd,
            'profit_factor': profit_factor,
            'final_capital': final_capital,
            'compound_return': (final_capital - CAPITAL) / CAPITAL * 100
        },
        'created_at': datetime.now().isoformat(),
        'data_period': {
            'start': str(df['timestamp'].min()),
            'end': str(df['timestamp'].max()),
            'candles': len(df)
        }
    }

    # JSON 저장
    json_path = project_root / "data" / f"{preset_name}.json"
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(preset_data, f, indent=2, ensure_ascii=False)

    print(f"\n[OK] 프리셋 저장: {json_path}")

print("\n" + "=" * 80)
